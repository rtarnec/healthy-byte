"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __knownSymbol = (name, symbol) => (symbol = Symbol[name]) ? symbol : Symbol.for("Symbol." + name);
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __forAwait = (obj, it, method) => (it = obj[__knownSymbol("asyncIterator")]) ? it.call(obj) : (obj = obj[__knownSymbol("iterator")](), it = {}, method = (key, fn) => (fn = obj[key]) && (it[key] = (arg) => new Promise((yes, no, done) => (arg = fn.call(obj, arg), done = arg.done, Promise.resolve(arg.value).then((value) => yes({ value, done }), no)))), method("next"), method("return"), it);
var mistral_llms_exports = {};
__export(mistral_llms_exports, {
  MistralConfigSchema: () => MistralConfigSchema,
  SUPPORTED_MISTRAL_MODELS: () => SUPPORTED_MISTRAL_MODELS,
  mistralModel: () => mistralModel,
  openCodestral: () => openCodestral,
  openCodestralMambda: () => openCodestralMambda,
  openMinistral3B: () => openMinistral3B,
  openMinistral8B: () => openMinistral8B,
  openMistral7B: () => openMistral7B,
  openMistral8x7B: () => openMistral8x7B,
  openMistralLarge: () => openMistralLarge,
  openMistralMedium: () => openMistralMedium,
  openMistralNemo: () => openMistralNemo,
  openMistralSaba: () => openMistralSaba,
  openMistralSmall: () => openMistralSmall,
  openMixtral8x22B: () => openMixtral8x22B,
  openPixtral: () => openPixtral,
  openPixtralLarge: () => openPixtralLarge,
  toMistralMessages: () => toMistralMessages,
  toMistralRequestBody: () => toMistralRequestBody,
  toMistralTextAndMedia: () => toMistralTextAndMedia
});
module.exports = __toCommonJS(mistral_llms_exports);
var import_genkit = require("genkit");
var import_model2 = require("genkit/model");
var import_genkit3 = require("genkit");
const MistralConfigSchema = import_model2.GenerationCommonConfigSchema.extend({
  visualDetailLevel: import_genkit3.z.enum(["auto", "low", "high"]).optional()
});
const openMistral7B = (0, import_model2.modelRef)({
  name: "mistral/open-mistral-7b",
  info: {
    versions: ["mistral-tiny-2312"],
    label: "Mistral - Mistral 7B",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMinistral3B = (0, import_model2.modelRef)({
  name: "mistral/ministral-3b",
  info: {
    versions: ["ministral-3b-latest", "ministral-3b-2410"],
    label: "Mistral - Ministral 3B",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMinistral8B = (0, import_model2.modelRef)({
  name: "mistral/ministral-8b",
  info: {
    versions: ["ministral-8b-latest", "ministral-8b-2410"],
    label: "Mistral - Ministral 8B",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistralNemo = (0, import_model2.modelRef)({
  name: "mistral/open-mistral-nemo",
  info: {
    versions: ["open-mistral-nemo", "pen-mistral-nemo-2407"],
    label: "Mistral - Nemo Model",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistralSaba = (0, import_model2.modelRef)({
  name: "mistral/mistral-saba",
  info: {
    versions: ["mistral-saba-latest", "mistral-saba-2502"],
    label: "Mistral - Saba Model",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openCodestralMambda = (0, import_model2.modelRef)({
  name: "mistral/open-codestral-mamba",
  info: {
    versions: ["open-codestral-mamba"],
    label: "Mistral - Codestral Mamba",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openCodestral = (0, import_model2.modelRef)({
  name: "mistral/codestral",
  info: {
    versions: ["codestral-latest", "codestral-2501"],
    label: "Mistral - Codestral",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistral8x7B = (0, import_model2.modelRef)({
  name: "mistral/open-mixtral-8x7b",
  info: {
    versions: ["open-mixtral-8x7b"],
    label: "Mistral - Mistral 8x7B",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMixtral8x22B = (0, import_model2.modelRef)({
  name: "mistral/open-mixtral-8x22b",
  info: {
    versions: ["open-mixtral-8x22b"],
    label: "Mistral - Mistral 8x22B",
    supports: {
      multiturn: true,
      tools: true,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistralSmall = (0, import_model2.modelRef)({
  name: "mistral/mistral-small",
  info: {
    versions: [
      "mistral-small-latest",
      "mistral-small-2402",
      "mistral-small-2501"
    ],
    label: "Mistral - Mistral Small",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistralMedium = (0, import_model2.modelRef)({
  name: "mistral/mistral-medium",
  info: {
    versions: ["mistral-medium-2312"],
    label: "Mistral - Mistral Medium",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openMistralLarge = (0, import_model2.modelRef)({
  name: "mistral/mistral-large",
  info: {
    versions: [
      "mistral-large-latest",
      "mistral-large-2402",
      "mistral-large-2407"
    ],
    label: "Mistral - Mistral Large",
    supports: {
      multiturn: true,
      tools: false,
      media: false,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openPixtralLarge = (0, import_model2.modelRef)({
  name: "mistral/pixtral-large",
  info: {
    versions: ["pixtral-large-latest", "pixtral-large-2411"],
    label: "Mistral - Pixtral Large",
    supports: {
      multiturn: true,
      tools: false,
      media: true,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
const openPixtral = (0, import_model2.modelRef)({
  name: "mistral/pixtral",
  info: {
    versions: ["pixtral-12b-2409"],
    label: "Mistral - Pixtral",
    supports: {
      multiturn: true,
      tools: false,
      media: true,
      systemRole: true,
      output: ["text", "json"]
    }
  },
  configSchema: import_model2.GenerationCommonConfigSchema
});
function toMistralRole(role) {
  switch (role) {
    case "user":
      return "user";
    case "model":
      return "assistant";
    case "system":
      return "system";
    case "tool":
      return "assistant";
    default:
      throw new Error(`Role ${role} doesn't map to a Mistral role.`);
  }
}
function toMistralTool(tool) {
  return {
    type: "function",
    function: {
      name: tool.name,
      parameters: tool.inputSchema,
      description: tool.description
    }
  };
}
function toMistralTextAndMedia(part) {
  if (part.text) {
    return {
      type: "text",
      text: part.text
    };
  } else if (part.media) {
    return {
      type: "image_url",
      imageUrl: {
        url: part.media.url
      }
    };
  }
  throw Error(
    `Unsupported genkit part fields encountered for current message role: ${JSON.stringify(part)}.`
  );
}
function toMistralMessages(messages) {
  const mistralMsgs = [];
  for (const message of messages) {
    const msg = new import_genkit.Message(message);
    const role = toMistralRole(message.role);
    if (role === "system") {
      mistralMsgs.push({
        role: "system",
        content: msg.text || ""
      });
    } else if (role === "user") {
      mistralMsgs.push({
        role: "user",
        content: msg.content.map((part) => toMistralTextAndMedia(part))
      });
    } else if (role === "assistant") {
      mistralMsgs.push({
        role: "assistant",
        content: msg.content.map((part) => toMistralTextAndMedia(part))
      });
    } else if (role === "tool") {
      mistralMsgs.push({
        role: "tool",
        content: msg.content.map((part) => toMistralTextAndMedia(part))
      });
    }
  }
  return mistralMsgs;
}
const finishReasonMap = {
  length: "length",
  stop: "stop",
  tool_calls: "stop",
  content_filter: "blocked"
};
const SUPPORTED_MISTRAL_MODELS = {
  "open-mistral-7b": openMistral7B,
  "open-mixtral-8x7b": openMistral8x7B,
  "open-mixtral-8x22b": openMixtral8x22B,
  "mistral-small": openMistralSmall,
  "mistral-medium": openMistralMedium,
  "mistral-large": openMistralLarge,
  "ministral-3b": openMinistral3B,
  "ministral-8b": openMinistral8B,
  "open-mistral-nemo": openMistralNemo,
  "open-codestral-mamba": openCodestralMambda,
  codestral: openCodestral,
  "mistral-saba": openMistralSaba,
  "pixtral-large": openPixtralLarge,
  pixtral: openPixtral
};
function fromMistralToolCall(toolCall) {
  if (!toolCall.function) {
    throw Error(
      `Unexpected mistral chunk choice. tool_calls was provided but one or more tool_calls is missing.`
    );
  }
  const f = toolCall.function;
  return {
    toolRequest: {
      name: f.name,
      ref: toolCall.id,
      input: typeof f.arguments === "string" ? JSON.parse(f.arguments) : f.arguments
    }
  };
}
function fromMistralChoice(choice) {
  var _a;
  const toolRequestParts = (_a = choice.message.toolCalls) == null ? void 0 : _a.map(fromMistralToolCall);
  return {
    index: choice.index,
    finishReason: finishReasonMap[choice.finishReason] || "other",
    message: {
      role: "model",
      content: toolRequestParts ? toolRequestParts : [
        {
          text: typeof choice.message.content === "string" ? choice.message.content : ""
        }
      ]
    },
    custom: {}
  };
}
function fromMistralChunkChoice(choice) {
  return {
    index: choice.index,
    finishReason: choice.finishReason ? finishReasonMap[choice.finishReason] || "other" : "unknown",
    message: {
      role: "model",
      content: [
        {
          text: typeof choice.delta.content === "string" ? choice.delta.content : ""
        }
      ]
    },
    custom: {}
  };
}
function toMistralRequestBody(modelName, request) {
  var _a, _b, _c, _d, _e, _f, _g;
  const model = SUPPORTED_MISTRAL_MODELS[modelName];
  if (!model) throw new Error(`Unsupported model: ${modelName}`);
  const mistralMessages = toMistralMessages(request.messages);
  const mappedModelName = ((_a = request.config) == null ? void 0 : _a.version) || model.version || modelName;
  let responseFormat;
  if (((_b = request.output) == null ? void 0 : _b.format) === "json") {
    responseFormat = { type: "json_object" };
  } else {
    responseFormat = null;
  }
  const body = {
    messages: mistralMessages,
    tools: (_c = request.tools) == null ? void 0 : _c.map(toMistralTool),
    model: mappedModelName,
    maxTokens: (_d = request.config) == null ? void 0 : _d.maxOutputTokens,
    temperature: (_e = request.config) == null ? void 0 : _e.temperature,
    topP: (_f = request.config) == null ? void 0 : _f.topP,
    n: request.candidates,
    stop: (_g = request.config) == null ? void 0 : _g.stopSequences,
    responseFormat
  };
  for (const key in body) {
    if (!body[key] || Array.isArray(body[key]) && !body[key].length)
      delete body[key];
  }
  return body;
}
function mistralModel(ai, name, client) {
  const modelId = `mistral/${name}`;
  const model = SUPPORTED_MISTRAL_MODELS[name];
  if (!model) throw new Error(`Unsupported model: ${name}`);
  return ai.defineModel(
    __spreadProps(__spreadValues({
      name: modelId
    }, model.info), {
      configSchema: SUPPORTED_MISTRAL_MODELS[name].configSchema
    }),
    (request, streamingCallback) => __async(this, null, function* () {
      var _a, _b, _c, _d, _e;
      let response;
      const body = toMistralRequestBody(name, request);
      if (streamingCallback) {
        const stream = yield client.chat.stream(body);
        try {
          for (var iter = __forAwait(stream), more, temp, error; more = !(temp = yield iter.next()).done; more = false) {
            const chunk = temp.value;
            (_a = chunk.data.choices) == null ? void 0 : _a.forEach((choice) => {
              const c = fromMistralChunkChoice(choice);
              streamingCallback({
                index: c.index,
                content: c.message.content
              });
            });
          }
        } catch (temp) {
          error = [temp];
        } finally {
          try {
            more && (temp = iter.return) && (yield temp.call(iter));
          } finally {
            if (error)
              throw error[0];
          }
        }
        response = yield client.chat.complete(body);
      } else {
        response = yield client.chat.complete(body);
      }
      return {
        candidates: ((_b = response.choices) == null ? void 0 : _b.map((c) => fromMistralChoice(c))) || [],
        usage: {
          inputTokens: (_c = response.usage) == null ? void 0 : _c.promptTokens,
          outputTokens: (_d = response.usage) == null ? void 0 : _d.completionTokens,
          totalTokens: (_e = response.usage) == null ? void 0 : _e.totalTokens
        },
        custom: response
      };
    })
  );
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MistralConfigSchema,
  SUPPORTED_MISTRAL_MODELS,
  mistralModel,
  openCodestral,
  openCodestralMambda,
  openMinistral3B,
  openMinistral8B,
  openMistral7B,
  openMistral8x7B,
  openMistralLarge,
  openMistralMedium,
  openMistralNemo,
  openMistralSaba,
  openMistralSmall,
  openMixtral8x22B,
  openPixtral,
  openPixtralLarge,
  toMistralMessages,
  toMistralRequestBody,
  toMistralTextAndMedia
});
//# sourceMappingURL=mistral_llms.js.map